// Source code dump of all files in e:\Documents\Llander\GitHub\IT6L-Project\app

// Http\Controllers\AdminController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;
use Illuminate\Validation\Rule;
use App\Models\AssignedRoom;
use App\Models\Booking;
use App\Models\Room;
use App\Models\User;
use App\Models\PaymentInfos;
use Carbon\Carbon;

class AdminController extends Controller {
  public function viewDashboard() {
    return view('admin.dashboard');
  }

  public function getDashboardData(Request $request) {
    $today = Carbon::today();
    $period = $request->query('period', 'weekly');

    $checkInToday = Booking::whereDate('SettledCheckIn', $today->toDateString())->where('BookingStatus', 'Ongoing')->count();
    $checkOutToday = Booking::whereDate('SettledCheckOut', $today->toDateString())->where('BookingStatus', 'Ended')->count();
    $totalInHotel = AssignedRoom::where('Status', 'Ongoing')->count();
    $availableRooms = Room::count() - $totalInHotel;
    $occupiedRooms = $totalInHotel;
    $revenueToday = (float) PaymentInfos::whereDate('updated_at', $today->toDateString())->where('PaymentStatus', 'Verified')->sum('TotalAmount');
    $monthlyRevenue = (float) PaymentInfos::whereMonth('created_at', $today->month)
      ->whereYear('created_at', $today->year)
      ->where('PaymentStatus', 'Verified')
      ->sum('TotalAmount');
    $occupancyRate = (Room::count() > 0) ? ($occupiedRooms / Room::count() * 100) : 0;

    Log::debug('Dashboard Metrics:', [
      'today' => $today->month,
      'checkInToday' => $checkInToday,
      'checkOutToday' => $checkOutToday,
      'totalInHotel' => $totalInHotel,
      'availableRooms' => $availableRooms,
      'occupiedRooms' => $occupiedRooms,
      'revenueToday' => $revenueToday,
      'monthlyRevenue' => $monthlyRevenue,
      'occupancyRate' => $occupancyRate,
    ]);

    $metrics = [
      'checkIn' => $checkInToday,
      'checkOut' => $checkOutToday,
      'totalInHotel' => $totalInHotel,
      'availableRooms' => $availableRooms,
      'occupiedRooms' => $occupiedRooms,
      'revenueToday' => $revenueToday,
      'monthlyRevenue' => $monthlyRevenue,
      'occupancyRate' => $occupancyRate,
    ];

    $labels = [];
    $revenueData = [];
    $occupancyData = [];

    if ($period === 'weekly') {
      $start = $today->copy()->startOfWeek();
      $end = $today->copy()->endOfWeek();
      for ($date = $start; $date <= $end; $date = $date->addDay()) {
        $labels[] = $date->format('D');
        $revenueData[] = (float) PaymentInfos::whereDate('updated_at', $date)->where('PaymentStatus', 'Verified')->avg('TotalAmount');
        $occupancyData[] = (Room::count() > 0) ? (AssignedRoom::whereDate('created_at', $date)
          ->whereHas('booking', function ($query) use ($date) {
            $query->where('SettledCheckIn', '<=', $date)->orWhere('SettledCheckOut', '>=', $date);
          })->count() / Room::count() * 100) : 0;
        // $occupancyData[] = (Room::count() > 0) ? (AssignedRoom::where('Status', 'Ongoing')
        //   ->whereHas('booking', function ($query) use ($date) {
        //     $query->where('SettledCheckIn', '<=', $date)->where('SettledCheckOut', '>=', $date);
        //   })->count() / Room::count() * 100) : 0;
      }
    } elseif ($period === 'monthly') {
      $start = $today->copy()->startOfMonth();
      $end = $today->copy()->endOfMonth();
      $weekCount = 1;
      for ($date = $start; $date <= $end; $date = $date->addWeek()) {
        $labels[] = 'Week ' . $weekCount++;
        $revenueData[] = (float) PaymentInfos::whereBetween('updated_At', [$date, $date->copy()->addWeek()])->where('PaymentStatus', 'Verified')->avg('TotalAmount');
        $occupancyData[] = (Room::count() > 0) ? (AssignedRoom::whereHas('booking', function ($query) use ($date) {
          $query->where('SettledCheckIn', '<=', $date->copy()->addWeek())->orWhere('SettledCheckOut', '>=', $date);
        })->count() / Room::count() * 100) : 0;
      }
    } elseif ($period === 'yearly') {
      $start = $today->copy()->startOfYear();
      $end = $today->copy()->endOfYear();
      for ($month = 1; $month <= 12; $month++) {
        $labels[] = Carbon::createFromDate($today->year, $month, 1)->format('M');
        $revenueData[] = (float) PaymentInfos::whereMonth('updated_at', $month)
          ->whereYear('created_at', $today->year)
          ->where('PaymentStatus', 'Verified')
          ->avg('TotalAmount');
        $occupancyData[] = (Room::count() > 0) ? (AssignedRoom::whereHas('booking', function ($query) use ($today, $month) {
          $query->whereMonth('CheckInDate', $month)->whereYear('SettledCheckIn', $today->year);
        })->count() / Room::count() * 100) : 0;
      }
    }

    $chartData = [
      'labels' => $labels,
      'revenueData' => $revenueData,
      'occupancyData' => array_map(function ($rate) {
        return round($rate, 2);
      }, $occupancyData),
    ];

    Log::debug('getDashboardData Response:', ['metrics' => $metrics, 'chartData' => $chartData]);

    return response()->json([
      'metrics' => $metrics,
      'chartData' => $chartData,
    ]);
  }

  public function viewMasterDashboard() {
    return view('admin.master_dashboard');
  }

  public function viewGuest(Request $request) {
    $currentDate = Carbon::today();
    $search = $request->input('search');
    $sort = $request->input('sort', 'ID');
    $direction = $request->input('direction', 'asc');
    $perPage = 30;
    $tab = $request->input('tab', 'pending');

    $validSortColumns = ['ID', 'UserName', 'RoomTypeName', 'RoomSizeName', 'HasServices', 'CheckInDate', 'CheckOutDate', 'TotalAmount', 'RoomName'];
    if (!in_array($sort, $validSortColumns)) {
      $sort = 'ID';
    }

    $baseQuery = Booking::with(['roomType', 'roomSize', 'servicesAdded', 'costDetails', 'assignedRooms.room'])
      ->leftJoin('users', 'BookingDetails.UserID', '=', 'users.id')
      ->leftJoin('RoomTypes', 'BookingDetails.RoomTypeID', '=', 'RoomTypes.ID')
      ->leftJoin('RoomSizes', 'BookingDetails.RoomSizeID', '=', 'RoomSizes.ID')
      ->leftJoin('BookingCostDetails', 'BookingDetails.ID', '=', 'BookingCostDetails.BookingDetailID')
      ->leftJoin('AssignedRooms', 'BookingDetails.ID', '=', 'AssignedRooms.BookingDetailID')
      ->leftJoin('Rooms', 'AssignedRooms.RoomID', '=', 'Rooms.ID')
      ->leftJoin('PaymentInfos', 'BookingDetails.ID', '=', 'PaymentInfos.BookingDetailID')
      ->select(
        'BookingDetails.ID',
        'BookingDetails.CheckInDate',
        'BookingDetails.CheckOutDate',
        'BookingDetails.BookingStatus',
        'users.name as UserName',
        'RoomTypes.RoomTypeName',
        'RoomSizes.RoomSizeName',
        'BookingCostDetails.TotalAmount',
        DB::raw('IFNULL(Rooms.RoomName, "") as RoomName'),
        DB::raw('EXISTS (SELECT 1 FROM ServicesAdded WHERE ServicesAdded.BookingDetailID = BookingDetails.ID) as HasServices'),
        DB::raw('COALESCE(SUM(CASE WHEN PaymentInfos.PaymentStatus = "Verified" THEN PaymentInfos.TotalAmount ELSE 0 END), 0) as AmountPaid')
      )
      ->groupBy(
        'BookingDetails.ID',
        'BookingDetails.CheckInDate',
        'BookingDetails.CheckOutDate',
        'BookingDetails.BookingStatus',
        'users.name',
        'RoomTypes.RoomTypeName',
        'RoomSizes.RoomSizeName',
        'BookingCostDetails.TotalAmount',
        'Rooms.RoomName'
      );

    if ($search) {
      $baseQuery->where(function ($q) use ($search) {
        $q->where('BookingDetails.ID', 'like', '%' . $search . '%')
          ->orWhere('users.name', 'like', '%' . $search . '%')
          ->orWhere('RoomTypes.RoomTypeName', 'like', '%' . $search . '%')
          ->orWhere('RoomSizes.RoomSizeName', 'like', '%' . $search . '%')
          ->orWhere('Rooms.RoomName', 'like', '%' . $search . '%');
      });
    }

    if ($sort === 'UserName') {
      $baseQuery->orderBy('users.name', $direction);
    } elseif ($sort === 'RoomTypeName') {
      $baseQuery->orderBy('RoomTypes.RoomTypeName', $direction);
    } elseif ($sort === 'RoomSizeName') {
      $baseQuery->orderBy('RoomSizes.RoomSizeName', $direction);
    } elseif ($sort === 'HasServices') {
      $baseQuery->orderBy('HasServices', $direction);
    } elseif ($sort === 'RoomName') {
      $baseQuery->orderByRaw("CAST(SUBSTRING_INDEX(Rooms.RoomName, '-', 1) AS UNSIGNED) $direction")
        ->orderByRaw("CAST(SUBSTRING_INDEX(Rooms.RoomName, '-', -1) AS UNSIGNED) $direction");
    } else {
      $baseQuery->orderBy('BookingDetails.' . $sort, $direction);
    }

    $reservations = null;
    $pageName = 'page';

    switch ($tab) {
      case 'pending':
        $query = clone $baseQuery;
        $reservations = $query->where('BookingDetails.BookingStatus', 'Pending')
          ->whereExists(function ($q) {
            $q->select(DB::raw(1))
              ->from('PaymentInfos')
              ->whereColumn('PaymentInfos.BookingDetailID', 'BookingDetails.ID')
              ->whereIn('PaymentInfos.PaymentStatus', ['Submitted', 'Pending']);
          })
          ->paginate($perPage, ['*'], $pageName)
          ->appends(['search' => $search, 'sort' => $sort, 'direction' => $direction, 'tab' => $tab]);
        break;
      case 'confirmed':
        $query = clone $baseQuery;
        $reservations = $query->where('BookingDetails.BookingStatus', 'Confirmed')
          ->paginate($perPage, ['*'], $pageName)
          ->appends(['search' => $search, 'sort' => $sort, 'direction' => $direction, 'tab' => $tab]);
        break;
      case 'ongoing':
        $query = clone $baseQuery;
        $reservations = $query->where('BookingDetails.BookingStatus', 'Ongoing')
          ->paginate($perPage, ['*'], $pageName)
          ->appends(['search' => $search, 'sort' => $sort, 'direction' => $direction, 'tab' => $tab]);
        break;
      case 'completed':
        $query = clone $baseQuery;
        $reservations = $query->where('BookingDetails.BookingStatus', 'Ended')
          ->paginate($perPage, ['*'], $pageName)
          ->appends(['search' => $search, 'sort' => $sort, 'direction' => $direction, 'tab' => $tab]);
        break;
      case 'cancelled':
        $query = clone $baseQuery;
        $reservations = $query->where('BookingDetails.BookingStatus', 'Cancelled')
          ->paginate($perPage, ['*'], $pageName)
          ->appends(['search' => $search, 'sort' => $sort, 'direction' => $direction, 'tab' => $tab]);
        break;
      default:
        abort(404);
    }

    if ($request->ajax()) {
      return response()->json([
        'html' => view("admin.partials.guest.tab_{$tab}", compact('reservations', 'search', 'sort', 'direction'))->render()
      ]);
    }

    return view('admin.guest', compact('reservations', 'search', 'sort', 'direction', 'tab'));
  }

  public function viewRooms(Request $request) {
    $search = $request->input('search');
    $sort = $request->input('sort', 'RoomName');
    $direction = $request->input('direction', 'asc');
    $perPage = 30;
    $tab = $request->input('tab', 'occupied');

    $validSortColumns = ['RoomName', 'RoomTypeName', 'RoomSizeName', 'Floor', 'status', 'Occupant'];
    if (!in_array($sort, $validSortColumns)) {
      $sort = 'RoomName';
    }

    $baseQuery = DB::table('Rooms')
      ->leftJoin('AssignedRooms', function ($join) {
        $join->on('Rooms.ID', '=', 'AssignedRooms.RoomID')
          ->where('AssignedRooms.Status', '=', 'Ongoing');
      })
      ->leftJoin('BookingDetails', 'AssignedRooms.BookingDetailID', '=', 'BookingDetails.ID')
      ->leftJoin('Users', 'BookingDetails.UserID', '=', 'Users.id')
      ->join('RoomTypes', 'Rooms.RoomTypeID', '=', 'RoomTypes.ID')
      ->join('RoomSizes', 'Rooms.RoomSizeID', '=', 'RoomSizes.ID')
      ->select(
        'Rooms.ID',
        'Rooms.RoomName',
        'RoomTypes.RoomTypeName',
        'RoomSizes.RoomSizeName',
        'Rooms.Floor',
        DB::raw("CASE WHEN AssignedRooms.ID IS NOT NULL THEN 'Occupied' ELSE 'Available' END as status"),
        DB::raw("COALESCE(Users.Name, 'None') as Occupant")
      );

    if ($search) {
      $baseQuery->where(function ($query) use ($search) {
        $query->where('Rooms.RoomName', 'like', "%$search%")
          ->orWhere('RoomTypes.RoomTypeName', 'like', "%$search%")
          ->orWhere('RoomSizes.RoomSizeName', 'like', "%$search%")
          ->orWhere('Rooms.Floor', 'like', "%$search%")
          ->orWhere('users.Name', 'like', "%$search%");
      });
    }

    if ($tab === 'occupied') {
      $baseQuery->whereNotNull('AssignedRooms.ID');
    } elseif ($tab === 'available') {
      $baseQuery->whereNull('AssignedRooms.ID');
    }

    try {
      $reservations = $baseQuery->orderBy($sort, $direction)->paginate($perPage);
    } catch (\Exception $e) {
      Log::error('viewRooms Query Error:', ['error' => $e->getMessage(), 'sql' => $baseQuery->toSql()]);
      return response()->json([
        'status' => 'error',
        'message' => 'Failed to load rooms data.',
        'error' => $e->getMessage()
      ], 500);
    }

    if ($request->ajax()) {
      return response()->json([
        'html' => view("admin.partials.rooms.tab_{$tab}", compact('reservations', 'sort', 'direction', 'search'))->render()
      ]);
    }

    return view('admin.rooms', compact('reservations', 'tab', 'sort', 'direction', 'search'));
  }

  public function viewFrontDesk() {
    return view('admin.frontdesk');
  }

  public function viewDeals() {
    return view('admin.deals');
  }

  public function viewRate() {
    return view('admin.rate');
  }

  public function viewBooking() {
    return view('admin.booking');
  }

  public function viewUserManagement(Request $request) {
    $search = $request->input('search');
    $sort = $request->input('sort', 'Name');
    $direction = $request->input('direction', 'asc');
    $perPage = 30;
    $tab = $request->input('tab', 'staff');

    $validSortColumns = ['Name', 'Role', 'email', 'created_at', 'updated_at'];
    if (!in_array($sort, $validSortColumns)) {
      $sort = 'Name';
    }

    $baseQuery = User::query();

    if ($search) {
      $baseQuery->where(function ($query) use ($search) {
        $query->where('Name', 'like', "%$search%")
          ->orWhere('email', 'like', "%$search%");
      });
    }

    if ($tab === 'staff') {
      $baseQuery->whereIn('Role', ['Admin', 'Manager']);
    } elseif ($tab === 'customers') {
      $baseQuery->where('Role', 'Customer');
    }

    $users = $baseQuery->orderBy($sort, $direction)->paginate($perPage);

    if ($request->ajax()) {
      return response()->json([
        'html' => view("admin.partials.usermanagement.tab_{$tab}", compact('users', 'sort', 'direction', 'search'))->render()
      ]);
    }

    return view('admin.usermanagement', compact('users', 'tab', 'sort', 'direction', 'search'));
  }

  public function addStaff(Request $request) {
    $validated = $request->validate([
      'Name' => 'required|string|max:255',
      'Role' => ['required', Rule::in(['Admin', 'Manager'])],
      'email' => 'required|email|unique:users',
      'password' => 'required|min:6|confirmed',
    ]);

    $user = User::create([
      'Name' => $validated['Name'],
      'Username' => strtolower(str_replace(' ', '_', $validated['Name'])),
      'Role' => $validated['Role'],
      'email' => $validated['email'],
      'password' => Hash::make($validated['password']),
    ]);

    return response()->json([
      'status' => 'success',
      'message' => 'Staff added successfully!',
    ]);
  }

  public function updateUser(Request $request, $id) {
    // Debug: Log raw request content and parsed data
    Log::debug('updateUser Raw Input:', ['content' => $request->getContent()]);
    Log::debug('updateUser Parsed Data:', $request->all());

    $user = User::findOrFail($id);

    // Treat empty password as null
    if ($request->input('password') === '') {
      $request->merge(['password' => null]);
    }
    if ($request->input('password_confirmation') === '') {
      $request->merge(['password_confirmation' => null]);
    }

    try {
      $validated = $request->validate([
        'Name' => 'required|string|max:255',
        'Role' => ['required', Rule::in(['Admin', 'Manager'])],
        'email' => 'required|email|unique:users,email,' . $id,
        'password' => 'nullable|min:6|confirmed',
      ]);
    } catch (\Illuminate\Validation\ValidationException $e) {
      Log::debug('updateUser Validation Errors:', $e->errors());
      throw $e;
    }

    $user->Name = $validated['Name'];
    $user->Role = $validated['Role'];
    $user->email = $validated['email'];
    if (!empty($validated['password'])) {
      $user->password = Hash::make($validated['password']);
    }
    $user->save();

    return response()->json([
      'status' => 'success',
      'message' => 'User updated successfully!',
    ]);
  }

  public function deleteUser($id) {
    if ($id == Auth::id()) {
      return response()->json([
        'status' => 'error',
        'message' => 'You cannot delete yourself!',
      ], 403);
    }

    $user = User::findOrFail($id);
    $user->delete();

    return response()->json([
      'status' => 'success',
      'message' => 'User deleted successfully!',
    ]);
  }
}


// Http\Controllers\AuthController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\User;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Auth;

class AuthController extends Controller {
  public function RegisterUser(Request $request) {
    // Check if the request is AJAX
    $isAjax = $request->expectsJson();

    $request->validateWithBag('register', [
      'Name' => 'required|regex:/^[A-Za-z]+(?:\s+[A-Za-z]+(?:\.[A-Za-z]*)?)?(?:\s+[A-Za-z]+(?:\.[A-Za-z]*)?){0,4}?$/m',
      'Username' => 'required|unique:users|regex:/^[A-Za-z0-9]+(_[A-Za-z0-9]+)?(\.[A-Za-z0-9]+)?$/',
      'email' => 'required|email|unique:users',
      'password' => 'required|min:6|confirmed',
      'password_confirmation' => 'required|min:6',
    ], [
      'Name.required' => 'The name field is required.',
      'Name.regex' => 'The name must be a valid name format, with optional Surname or Middle Initial.',
      'Username.required' => 'The username field is required.',
      'Username.unique' => 'This username is already taken.',
      'Username.regex' => 'The username must contain only letters, numbers, one optional underscore, and one optional dot (e.g., "john_doe.123"). No spaces or other special characters are allowed.',
      'email.required' => 'The email field is required.',
      'email.email' => 'The email must be a valid email address.',
      'email.unique' => 'This email is already registered.',
      'password.required' => 'The password field is required.',
      'password.min' => 'The password must be at least 6 characters.',
      'password.confirmed' => 'The password confirmation does not match.',
      'password_confirmation.required' => 'The password confirmation field is required.',
      'password_confirmation.min' => 'The password confirmation must be at least 6 characters.',
    ]);

    $user = User::create([
      'Name' => ucwords($request->Name),
      'Username' => $request->Username,
      'email' => $request->email,
      'password' => Hash::make($request->password),
    ]);

    // Automatically log in the user after registration
    Auth::login($user);

    if ($isAjax) {
      return response()->json([
        'status' => 'success',
        'message' => 'Registration successful! You are now logged in.',
        'user' => [
          'Name' => $user->Name,
          'email' => $user->email,
          'Role' => $user->Role,
        ],
      ]);
    }

    return back()->with('toast_success', 'Registration successful! You are now logged in.');
  }

  public function LoginUser(Request $request) {
    // Check if the request is AJAX
    $isAjax = $request->expectsJson();

    $request->validate([
      'email' => 'required|email',
      'password' => 'required',
    ]);

    if (!Auth::attempt($request->only('email', 'password'))) {
      if ($isAjax) {
        return response()->json([
          'status' => 'error',
          'message' => 'Login failed. Check your credentials.',
          'errors' => [
            'email' => ['Invalid credentials'],
          ],
        ], 422);
      }
      return back()->with([
        'toast_error' => 'Login failed. Check your credentials.',
        'LoginError' => 'Login failed. Check your credentials.'
      ])->withInput($request->only('email'));
    }

    $user = Auth::user();
    if ($isAjax) {
      return response()->json([
        'status' => 'success',
        'message' => 'Login successful!',
        'user' => [
          'Name' => $user->Name,
          'email' => $user->email,
          'Role' => $user->Role,
        ],
        'redirect' => $user->Role === 'Admin' ? route('admin.dashboard') : null,
      ]);
    }

    if ($user->Role === 'Admin') {
      return redirect()->route('admin.dashboard');
    }
    return back()->with('toast_success', 'Login successful!');
  }

  public function LogoutUser(Request $request) {
    // Check if the request is AJAX
    $isAjax = $request->expectsJson();

    Auth::logout();
    $request->session()->invalidate();
    $request->session()->regenerateToken();

    if ($isAjax) {
      return response()->json([
        'status' => 'success',
        'message' => 'Logout successful!',
        'csrf_token' => csrf_token(),
      ]);
    }

    return redirect()->route('home')->with('toast_success', 'Logout successful!');
  }
}


// Http\Controllers\BookingController.php
<?php

namespace App\Http\Controllers;

use App\Models\Booking;
use App\Models\BookingCostDetail;
use App\Models\RoomType;
use App\Models\RoomSize;
use App\Models\Service;
use App\Models\UserLoyalty;
use App\Models\LoyaltyTier;
use App\Models\PaymentInfos;
use App\Models\PaymentType_Card;
use App\Models\PaymentType_EPayment;
use App\Models\PaymentType_Paypal;
use App\Models\CashbackThreshold;
use App\Models\LoyaltyPointTransaction;
use App\Models\PaymentType_BankTransfer;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Validator;
use App\Models\ServiceAdded;
use Carbon\Carbon;

class BookingController extends Controller {
  public function AppendBooking(Request $request) {
    $roomSize = RoomSize::where('RoomSizeName', $request->RoomSize)->firstOrFail();
    $maxGuests = $roomSize->RoomCapacity;

    $request->validate([
      'CheckInDate' => 'required|date|after_or_equal:today',
      'CheckOutDate' => 'required|date|after:CheckInDate',
      'RoomType' => 'required|string|in:Standard,Executive,Deluxe',
      'RoomSize' => 'required|string|in:Single,Double,Family',
      'NumberOfGuests' => "required|integer|min:1|max:$maxGuests",
      'Services' => 'nullable|array',
      'Services.*' => 'integer|exists:Services,ID|distinct',
    ]);

    // dd($request);

    DB::beginTransaction();
    try {
      $room = RoomType::where('RoomTypeName', $request->RoomType)->firstOrFail();
      $roomSize = RoomSize::where('RoomSizeName', $request->RoomSize)->firstOrFail();

      // Calculate number of nights
      $checkIn = Carbon::parse($request->CheckInDate);
      $checkOut = Carbon::parse($request->CheckOutDate);
      $nights = $checkIn->diffInDays($checkOut);

      // Room cost: base price + succeeding nights
      $roomBasePrice = $room->RoomPrice;
      $roomSucceedingNightsPrice = $nights > 1 ? $room->SucceedingNights * ($nights - 1) : 0;

      // Guest fee: 0 for Family rooms, otherwise PricePerPerson * NumberOfGuests
      $guestFee = $roomSize->PricePerPerson * ($request->NumberOfGuests - 1);

      // Service cost: base price + succeeding nights
      $serviceBasePrice = 0;
      $serviceSucceedingNightsPrice = 0;
      if ($request->filled('Services')) {
        $services = Service::whereIn('ID', $request->Services)->get();
        $serviceBasePrice = $services->sum('ServicePrice');
        $serviceSucceedingNightsPrice = $nights > 1 ? $serviceBasePrice * ($nights - 1) : 0;
      }

      // Calculate subtotal and apply loyalty discount
      $subtotal = $roomBasePrice + $roomSucceedingNightsPrice + $guestFee + $serviceBasePrice + $serviceSucceedingNightsPrice;
      $userLoyalty = UserLoyalty::firstOrCreate(
        ['UserID' => Auth::id()],
        ['LoyaltyPoints' => 0, 'LoyaltyTierID' => null]
      );
      $discount = 0;
      if ($userLoyalty->LoyaltyTierID) {
        $tier = LoyaltyTier::find($userLoyalty->LoyaltyTierID);
        $discount = $subtotal * ($tier->Discount / 100);
      }
      $totalAmount = $subtotal - $discount;

      $booking = new Booking();
      $booking->UserID = Auth::id();
      $booking->CheckInDate = $request->CheckInDate;
      $booking->CheckOutDate = $request->CheckOutDate;
      $booking->RoomTypeID = $room->ID;
      $booking->RoomSizeID = $roomSize->ID;
      $booking->NumberOfGuests = $request->NumberOfGuests;
      $booking->BookingStatus = 'Pending';
      $booking->save();

      if ($request->filled('Services')) {
        foreach ($request->Services as $serviceID) {
          ServiceAdded::create([
            'BookingDetailID' => $booking->ID,
            'ServiceID' => $serviceID,
          ]);
        }
      }

      BookingCostDetail::create([
        'BookingDetailID' => $booking->ID,
        'RoomBasePrice' => $roomBasePrice,
        'RoomSucceedingNightsPrice' => $roomSucceedingNightsPrice,
        'Nights' => $nights,
        'GuestFee' => $guestFee,
        'ServiceBasePrice' => $serviceBasePrice,
        'ServiceSucceedingNightsPrice' => $serviceSucceedingNightsPrice,
        'Subtotal' => $subtotal,
        'Discount' => $discount,
        'TotalAmount' => $totalAmount,
      ]);

      DB::commit();
      return redirect()->route('checkout')->with([
        'BookingID' => $booking->ID,
        'TotalAmount' => $totalAmount,
        'RoomBasePrice' => $roomBasePrice,
        'RoomSucceedingNightsPrice' => $roomSucceedingNightsPrice,
        'Nights' => $nights,
        'GuestFee' => $guestFee,
        'ServiceBasePrice' => $serviceBasePrice,
        'ServiceSucceedingNightsPrice' => $serviceSucceedingNightsPrice,
        'Subtotal' => $subtotal,
        'Discount' => $discount,
      ]);
    } catch (\Exception $e) {
      DB::rollBack();
      return back()->with('toast_error', 'Failed to save booking: ' . $e->getMessage());
    }
    // return back()->with('toast_success', 'Booking successful!');
  }

  public function CancelBooking(Request $request, $bookingID) {
    $this->middleware('auth');

    DB::beginTransaction();
    try {
      $booking = Booking::where('ID', $bookingID)
        ->where('UserID', Auth::id())
        ->firstOrFail();

      // Delete related records
      Booking::where('ID', $bookingID)->delete();
      ServiceAdded::where('BookingDetailID', $bookingID)->delete();
      $booking->delete();

      DB::commit();
      return redirect()->route('booking')->with('toast_success', 'Booking cancelled successfully!');
    } catch (\Exception $e) {
      DB::rollBack();
      // abort(0, $e->getMessage());
      return back()->with('toast_error', 'Failed to cancel booking: ' . $e->getMessage());
    }
  }
}


// Http\Controllers\CheckoutController.php
<?php

namespace App\Http\Controllers;

use App\Models\Booking;
use App\Models\CashbackThreshold;
use App\Models\PaymentInfos;
use App\Models\PaymentType_BankTransfer;
use App\Models\PaymentType_Card;
use App\Models\PaymentType_Paypal;
use App\Models\LoyaltyPointTransaction;
use App\Models\LoyaltyTier;
use App\Models\PaymentType_EPayment;
use App\Models\UserLoyalty;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;

class CheckoutController extends Controller {
  public function CheckoutForm(Request $request) {
    $booking = null;
    $costDetails = null;
    $tier = null;

    // Try session BookingID first
    $bookingID = session('BookingID');
    if ($bookingID) {
      $booking = Booking::with(['roomType', 'roomSize', 'servicesAdded', 'costDetails'])
        ->where('ID', $bookingID)
        ->where('UserID', Auth::id())
        ->first();
    }
    // dd($booking);

    // If no session booking, get latest pending booking
    if (!$booking) {
      $booking = Booking::with(['roomType', 'roomSize', 'servicesAdded', 'costDetails'])
        ->where('UserID', Auth::id())
        ->where('BookingStatus', 'Pending')
        ->orderBy('created_at', 'desc')
        ->first();
    }

    if ($booking) {
      $costDetails = $booking->costDetails;
      $userLoyalty = UserLoyalty::where('UserID', Auth::id())->first();
      if ($userLoyalty && $userLoyalty->LoyaltyTierID) {
        $tier = LoyaltyTier::where('ID', $userLoyalty->LoyaltyTierID)->first();
      }

      $request->session()->put('BookingID', $booking->ID);
    }

    return view('customer.payment', [
      'title' => 'Booking Details',
      'tier' => $tier,
      'booking' => $booking,
      'costDetails' => $costDetails,
      'PaymentProcessed' => $booking ? PaymentInfos::where('BookingDetailID', $booking->ID)
        ->where('PaymentStatus', 'Submitted')
        ->first() : null,
    ]);
  }
  public function ProcessPayment(Request $request) {
    // dd($request);
    $rules = [
      'BookingDetailID' => 'required|exists:BookingDetails,ID',
      'TotalAmount' => 'required|numeric|min:0',
      'paymentMethod' => 'required|in:gcashPaymaya,paypal,creditCard,bankTransfer',
    ];

    if ($request->paymentMethod === 'gcashPaymaya') {
      $rules['ECashMobileNum'] = 'required|string|max:11|regex:/^09\d{9}$/';
      $rules['ECashReference'] = 'required|string|max:20';
    } elseif ($request->paymentMethod === 'paypal') {
      $rules['PaypalReference'] = 'required|string|max:255';
    } elseif ($request->paymentMethod === 'creditCard') {
      $rules['CardNumber'] = 'required|string|regex:/^\d{16}$/';
      $rules['CardName'] = 'required|string|max:255';
      $rules['CardExpiry'] = 'required|string|regex:/^\d{2}\/\d{2}$/';
      $rules['CardCVC'] = 'required|string|regex:/^\d{3,4}$/';
    } elseif ($request->paymentMethod === 'bankTransfer') {
      $rules['AccountName'] = 'required|string|max:255';
      $rules['AccountNumber'] = 'required|string|max:255';
      $rules['RoutingNumber'] = 'required|string|max:255';
    }

    $validator = Validator::make($request->all(), $rules);
    // dd($validator);
    if ($validator->fails()) {
      return back()->withErrors($validator)->withInput($request->all());
    }

    DB::beginTransaction();
    try {
      $userLoyalty = UserLoyalty::firstOrCreate(
        ['UserID' => Auth::id()],
        ['LoyaltyPoints' => 0, 'LoyaltyTierID' => null]
      );

      $totalAmount = $request->TotalAmount;
      if ($userLoyalty->LoyaltyTierID) {
        $tier = LoyaltyTier::find($userLoyalty->LoyaltyTierID);
        $discount = $tier->Discount / 100;
        $totalAmount *= (1 - $discount);
      }

      $paymentInfo = PaymentInfos::where('BookingDetailID', $request->BookingDetailID)->first();

      if (!$paymentInfo) {
        $paymentInfo = PaymentInfos::create([
          'BookingDetailID' => $request->BookingDetailID,
          'TotalAmount' => $totalAmount,
          'PaymentStatus' => 'Submitted',
          'PaymentMethod' => $request->paymentMethod === 'gcashPaymaya' ? 'EPayment' : ucfirst($request->paymentMethod),
          'created_at' => now(),
          'updated_at' => now(),
        ]);
      } else {
        $paymentInfo->update([
          'TotalAmount' => $totalAmount,
          'PaymentStatus' => 'Submitted',
          'PaymentMethod' => $request->paymentMethod === 'gcashPaymaya' ? 'EPayment' : ucfirst($request->paymentMethod),
          'updated_at' => now(),
        ]);
      }


      if ($request->paymentMethod === 'gcashPaymaya') {
        PaymentType_EPayment::create([
          'PaymentInfoID' => $paymentInfo->ID,
          'Number' => $request->ECashMobileNum,
          'ReferenceNum' => $request->ECashReference,
          'Amount' => $totalAmount,
        ]);
      } elseif ($request->paymentMethod === 'paypal') {
        PaymentType_Paypal::create([
          'PaymentInfoID' => $paymentInfo->ID,
          'ReferenceNum' => $request->PaypalReference,
          'Amount' => $totalAmount,
        ]);
      } elseif ($request->paymentMethod === 'creditCard') {
        PaymentType_Card::create([
          'PaymentInfoID' => $paymentInfo->ID,
          'CardHolderName' => $request->CardName,
          'CardNumber' => $request->CardNumber,
          'ExpiryDate' => $request->CardExpiry,
          'CVC' => $request->CardCVC,
        ]);
      } elseif ($request->paymentMethod === 'bankTransfer') {
        PaymentType_BankTransfer::create([
          'PaymentInfoID' => $paymentInfo->ID,
          'AccountName' => $request->AccountName,
          'AccountNumber' => $request->AccountNumber,
          'RoutingNumber' => $request->RoutingNumber,
        ]);
      }

      $cashback = CashbackThreshold::where('MinPaidAmount', '<=', $totalAmount)
        ->orderBy('MinPaidAmount', 'desc')
        ->first();
      if ($cashback) {
        $points = $totalAmount * ($cashback->CashbackPercentile / 100);
        $userLoyalty->increment('LoyaltyPoints', $points);

        LoyaltyPointTransaction::create([
          'UserID' => Auth::id(),
          'Points' => $points,
          'TransactionType' => 'Earned',
          'PaymentInfoID' => $paymentInfo->ID,
          'Description' => "Cashback for payment of {$totalAmount} at {$cashback->CashbackPercentile}%",
        ]);
      }

      $newTier = LoyaltyTier::where('MinPoints', '<=', $userLoyalty->LoyaltyPoints)
        ->orderBy('MinPoints', 'desc')
        ->first();
      if ($newTier && $newTier->ID != $userLoyalty->LoyaltyTierID) {
        $userLoyalty->update(['LoyaltyTierID' => $newTier->ID]);
      }

      DB::commit();
      $request->session()->forget(['BookingID', 'TotalAmount']);
      return redirect()->route('booking')->with('toast_success', 'Payment submitted successfully!');
    } catch (\Exception $e) {
      DB::rollBack();
      return back()->with('toast_error', 'Payment failed: ' . $e->getMessage());
    }
  }
}


// Http\Controllers\Controller.php
<?php

namespace App\Http\Controllers;

use Illuminate\Routing\Controller as BaseController;

abstract class Controller extends BaseController {
  //
}


// Http\Controllers\PageController.php
<?php

namespace App\Http\Controllers;

use App\Models\Booking;
use App\Models\LoyaltyTier;
use App\Models\Service;
use App\Models\PaymentInfos;
use Illuminate\Support\Facades\Auth;
use App\Models\RoomSize;
use App\Models\RoomType;
use App\Models\UserLoyalty;
use Illuminate\Http\Request;

class PageController extends Controller {
  public function home() {
    return view('customer.home', ['title' => 'Home', 'Rooms' => RoomType::all()]);
  }

  public function explore() {
    return view('customer.explore', ['title' => 'Explore', 'Services' => Service::get()]);
  }

  public function rooms() {
    return view('customer.rooms', ['title' => 'Rooms', 'Rooms' => RoomType::get()]);
  }

  public function about() {
    return view('customer.about', ['title' => 'About']);
  }

  public function contact() {
    return view('customer.contact', ['title' => 'Contact']);
  }

  public function booking(Request $request) {
    $activeBooking = Booking::where('UserID', Auth::id())
      ->whereIn('BookingStatus', ['Confirmed', 'Ongoing'])
      ->exists();

    if ($activeBooking) {
      return redirect()->route('reservation')->with('toast_info', 'You have an active reservation.');
    }

    $ChosenRoom = $request->input('ChosenRoom');

    // Validate ChosenRoom against RoomType names
    $validRoomTypes = RoomType::pluck('RoomTypeName')->toArray();
    if ($ChosenRoom && !in_array($ChosenRoom, $validRoomTypes)) {
      return redirect()->route('rooms')->with('toast_error', 'Invalid room type selected.');
    }

    return view('customer.booking', [
      'title' => 'Booking',
      'RoomSizes' => RoomSize::get(),
      'RoomTypes' => RoomType::get(),
      'Services' => Service::where('ServiceStatus', 'Available')->get(),
      'HasPendingBooking' => Booking::where('UserID', Auth::id())
        ->where('BookingStatus', 'Pending')
        ->orderBy('created_at', 'desc')
        ->first(),
      'ChosenRoom' => $ChosenRoom,
    ]);
  }

  public function Reservation() {
    $reservation = Booking::with(['roomType', 'roomSize', 'servicesAdded', 'costDetails', 'assignedRooms.room'])
      ->where('UserID', Auth::id())
      ->whereIn('BookingStatus', ['Confirmed', 'Ongoing'])
      ->whereHas('paymentInfo', function ($query) {
        $query->where('PaymentStatus', 'Verified');
      })
      ->whereHas('assignedRooms', function ($query) {
        $query->whereNotNull('RoomID');
      })
      ->orderBy('created_at', 'desc')
      ->first();

    return view('customer.reservation', [
      'title' => 'Reservation',
      'reservation' => $reservation,
    ]);
  }
}


// Http\Controllers\ReservationActionsController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use App\Models\AssignedRoom;
use App\Models\Booking;
use App\Models\Room;
use App\Models\PaymentInfos;
use App\Models\UserLoyalty;
use App\Models\LoyaltyPointTransaction;
use App\Models\LoyaltyTier;
use App\Models\CashbackThreshold;

class ReservationActionsController extends Controller {
  public function __construct() {
    $this->middleware('RestrictByRole:Admin');
  }

  public function reviewBooking($id) {
    Log::debug(url()->previous());
    $booking = Booking::with([
      'user',
      'roomType',
      'roomSize',
      'servicesAdded',
      'costDetails',
      'assignedRooms.room',
      'paymentInfo' => function ($query) {
        $query->with(['cashpayment', 'cardpayment', 'epayment', 'paypalpayment', 'bankTransferpayment']);
      }
    ])->findOrFail($id);


    // dd($booking);

    return view('admin.reviewbooking', [
      'booking' => $booking,
      'prevRoute' => url()->previous(),
    ]);
  }

  public function acceptPayment($id) {
    DB::beginTransaction();
    try {
      $booking = Booking::findOrFail($id);
      if ($booking->BookingStatus !== 'Pending' || !$booking->paymentInfo || $booking->paymentInfo->PaymentStatus !== 'Submitted') {
        return redirect()->route('admin.guest')->with('toast_error', 'Invalid booking or payment status.');
      }

      $room = Room::where('RoomTypeID', $booking->RoomTypeID)
        ->where('RoomSizeID', $booking->RoomSizeID)
        ->whereNotIn('ID', function ($q) use ($booking) {
          $q->select('RoomID')
            ->from('AssignedRooms')
            ->join('BookingDetails', 'AssignedRooms.BookingDetailID', '=', 'BookingDetails.ID')
            ->whereIn('BookingDetails.BookingStatus', ['Confirmed', 'Ongoing'])
            ->where('BookingDetails.CheckInDate', '<=', $booking->CheckOutDate)
            ->where('BookingDetails.CheckOutDate', '>=', $booking->CheckInDate);
        })
        ->first();

      if (!$room) {
        return redirect()->route('admin.guest')->with('toast_error', 'No available room for this booking.');
      }

      AssignedRoom::create([
        'BookingDetailID' => $booking->ID,
        'RoomID' => $room->ID,
        'Status' => 'Ongoing',
      ]);

      $booking->update(['BookingStatus' => 'Confirmed']);
      $booking->paymentInfo->update(['PaymentStatus' => 'Verified']);

      DB::commit();
      return redirect()->route('admin.guest')->with('toast_success', 'Payment verified and room assigned.');
    } catch (\Exception $e) {
      DB::rollBack();
      return redirect()->route('admin.guest')->with('toast_error', 'Failed to verify payment: ' . $e->getMessage());
    }
  }

  public function rejectPayment($id) {
    DB::beginTransaction();
    try {
      $booking = Booking::findOrFail($id);
      if ($booking->BookingStatus !== 'Pending' || !$booking->paymentInfo || $booking->paymentInfo->PaymentStatus !== 'Submitted') {
        return redirect()->route('admin.guest')->with('toast_error', 'Invalid booking or payment status.');
      }

      $booking->update(['BookingStatus' => 'Cancelled']);
      $booking->paymentInfo->update(['PaymentStatus' => 'Failed']);

      DB::commit();
      return redirect()->route('admin.guest')->with('toast_success', 'Payment rejected and booking cancelled.');
    } catch (\Exception $e) {
      DB::rollBack();
      return redirect()->route('admin.guest')->with('toast_error', 'Failed to reject payment: ' . $e->getMessage());
    }
  }

  public function checkIn($id) {
    DB::beginTransaction();
    try {
      $booking = Booking::findOrFail($id);
      if ($booking->BookingStatus !== 'Confirmed') {
        return redirect()->route('admin.guest')->with('toast_error', 'Booking must be confirmed to check in.');
      }

      $booking->update(['BookingStatus' => 'Ongoing', 'SettledCheckIn' => now()]);
      // Award loyalty points based on CashbackThresholds
      $user = $booking->user;
      $totalAmount = $booking->paymentInfo->TotalAmount;
      $threshold = CashbackThreshold::where('MinPaidAmount', '<=', $totalAmount)
        ->orderBy('MinPaidAmount', 'desc')
        ->first();
      $points = $threshold ? ($totalAmount * $threshold->CashbackPercentile / 100) : 0;

      if ($points > 0) {
        $userLoyalty = UserLoyalty::firstOrCreate(
          ['UserID' => $user->id],
          ['LoyaltyPoints' => 0, 'LoyaltyTierID' => null]
        );

        $userLoyalty->increment('LoyaltyPoints', $points);

        LoyaltyPointTransaction::create([
          'UserID' => $user->id,
          'Points' => $points,
          'TransactionType' => 'Earned',
          'PaymentInfoID' => $booking->paymentInfo->ID,
          'Description' => "Cashback for booking ID {$booking->ID}",
        ]);

        // Update loyalty tier
        $newTier = LoyaltyTier::where('MinPoints', '<=', $userLoyalty->LoyaltyPoints)
          ->orderBy('MinPoints', 'desc')
          ->first();

        if ($newTier && $newTier->ID !== $userLoyalty->LoyaltyTierID) {
          $userLoyalty->update(['LoyaltyTierID' => $newTier->ID]);
        }
      }

      DB::commit();
      return redirect()->route('admin.guest')->with('toast_success', 'Guest checked in successfully.' . ($points > 0 ? ' Awarded ' . $points . ' loyalty points.' : ''));
    } catch (\Exception $e) {
      DB::rollBack();
      dd($e);
      return redirect()->route('admin.guest')->with('toast_error', 'Failed to check in: ' . $e->getMessage());
    }
  }

  public function checkOut($id) {
    DB::beginTransaction();
    try {
      $booking = Booking::findOrFail($id);
      if ($booking->BookingStatus !== 'Ongoing') {
        return redirect()->route('admin.guest')->with('toast_error', 'Booking must be ongoing to check out.');
      }

      $booking->update(['BookingStatus' => 'Ended', 'SettledCheckOut' => now()]);
      $booking->assignedRooms()->update(['Status' => 'Ended']);

      DB::commit();
      return redirect()->route('admin.guest')->with('toast_success', 'Guest checked out successfully.');
    } catch (\Exception $e) {
      DB::rollBack();
      return redirect()->route('admin.guest')->with('toast_error', 'Failed to check out: ' . $e->getMessage());
    }
  }

  public function cancelBooking($id) {
    DB::beginTransaction();
    try {
      $booking = Booking::findOrFail($id);
      if (!in_array($booking->BookingStatus, ['Pending', 'Confirmed', 'Ongoing'])) {
        return redirect()->route('admin.guest')->with('toast_error', 'Booking cannot be cancelled in its current status.');
      }

      $booking->update(['BookingStatus' => 'Cancelled']);
      if ($booking->paymentInfo && $booking->paymentInfo->PaymentStatus === 'Verified') {
        $booking->paymentInfo->update(['PaymentStatus' => 'Failed']);
      }
      $booking->assignedRooms()->update(['Status' => 'Ended']);

      DB::commit();
      return redirect()->route('admin.guest')->with('toast_success', 'Booking cancelled successfully.');
    } catch (\Exception $e) {
      DB::rollBack();
      return redirect()->route('admin.guest')->with('toast_error', 'Failed to cancel booking: ' . $e->getMessage());
    }
  }
}


// Http\Middleware\RestrictByRole.php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;

class RestrictByRole {
  /**
   * Handle an incoming request.
   *
   * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
   */
  public function handle(Request $request, Closure $next, ...$roles): Response {
    if (!Auth::check()) {
      return redirect()->route('home')->with(['toast_error' => 'You must login first.']);
      // abort(403, 'Unauthorized action.');
    }

    if (Auth::user()->Role !== 'Admin' && !in_array(Auth::user()->Role, $roles)) {
      return redirect()->route('home')->with(['toast_error' => 'Unauthorized action.']);
      // abort(403, 'Unauthorized action.');
    }
    return $next($request);
  }
}


// Models\AssignedRoom.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class AssignedRoom extends Model {
  protected $table = 'AssignedRooms';
  protected $primaryKey = 'ID';
  protected $fillable = [
    'BookingDetailID',
    'RoomID',
    'Status',
  ];

  public function booking() {
    return $this->belongsTo(Booking::class, 'BookingDetailID', 'ID');
  }

  public function room() {
    return $this->belongsTo(Room::class, 'RoomID', 'ID');
  }
}


// Models\Booking.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Booking extends Model {
  protected $table = 'BookingDetails';
  protected $primaryKey = 'ID';
  protected $fillable = ['UserID', 'RoomTypeID', 'CheckInDate', 'CheckOutDate', 'SettledCheckIn', 'SettledCheckOut', 'NumberOfGuests', 'RoomSizeID', 'BookingStatus'];

  protected $casts = [
    'CheckInDate' => 'datetime',
    'CheckOutDate' => 'datetime',
  ];

  public function user() {
    return $this->belongsTo(User::class, 'UserID', 'id');
  }

  public function roomType() {
    return $this->belongsTo(RoomType::class, 'RoomTypeID', 'ID');
  }

  public function roomSize() {
    return $this->belongsTo(RoomSize::class, 'RoomSizeID', 'ID');
  }

  public function servicesAdded() {
    return $this->belongsToMany(Service::class, 'ServicesAdded', 'BookingDetailID', 'ServiceID');
  }

  public function paymentInfo() {
    return $this->hasOne(PaymentInfos::class, 'BookingDetailID', 'ID');
  }

  public function costDetails() {
    return $this->hasOne(BookingCostDetail::class, 'BookingDetailID', 'ID');
  }

  public function assignedRooms() {
    return $this->hasMany(AssignedRoom::class, 'BookingDetailID', 'ID');
  }
}


// Models\BookingCostDetail.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class BookingCostDetail extends Model {
  protected $table = 'BookingCostDetails';
  protected $primaryKey = 'ID';
  protected $fillable = [
    'BookingDetailID',
    'RoomBasePrice',
    'RoomSucceedingNightsPrice',
    'Nights',
    'GuestFee',
    'ServiceBasePrice',
    'ServiceSucceedingNightsPrice',
    'Subtotal',
    'Discount',
    'TotalAmount'
  ];

  protected $casts = [
    'RoomBasePrice' => 'decimal:2',
    'RoomSucceedingNightsPrice' => 'decimal:2',
    'GuestFee' => 'decimal:2',
    'ServiceBasePrice' => 'decimal:2',
    'ServiceSucceedingNightsPrice' => 'decimal:2',
    'Subtotal' => 'decimal:2',
    'Discount' => 'decimal:2',
    'TotalAmount' => 'decimal:2',
  ];

  public function booking() {
    return $this->belongsTo(Booking::class, 'BookingDetailID', 'ID');
  }
}


// Models\CashbackThreshold.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class CashbackThreshold extends Model {
  protected $table = 'CashbackThresholds';
  protected $primaryKey = 'ID';
  protected $fillable = [
    'ThresholdName',
    'ThresholdDescription',
    'MinPaidAmount',
    'CashbackPercentile',
  ];

  protected $casts = [
    'MinPaidAmount' => 'decimal:2',
    'CashbackPercentile' => 'decimal:2'
  ];
}


// Models\LoyaltyPointTransaction.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class LoyaltyPointTransaction extends Model {
  protected $table = 'LoyaltyPointTransactions';
  protected $primaryKey = 'ID';
  protected $fillable = ['UserID', 'Points', 'TransactionType', 'PaymentInfoID', 'Description'];

  protected $casts = [
    'Points' => 'decimal:2',
    'TransactionType' => 'string',
  ];

  public function user() {
    return $this->belongsTo(User::class, 'UserID', 'ID');
  }

  public function paymentInfo() {
    return $this->belongsTo(PaymentInfos::class, 'PaymentInfoID', 'ID');
  }
}


// Models\LoyaltyTier.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class LoyaltyTier extends Model {
  protected $table = 'LoyaltyTiers';
  protected $primaryKey = 'ID';
  protected $fillable = ['TierName', 'TierDescription', 'MinPoints', 'Discount'];

  protected $casts = [
    'MinPoints' => 'integer',
    'Discount' => 'decimal:2',
  ];
}


// Models\PaymentInfos.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class PaymentInfos extends Model {
  protected $table = 'PaymentInfos';

  protected $primaryKey = 'ID';

  protected $fillable = [
    'BookingDetailID',
    'TotalAmount',
    'PaymentStatus',
    'PaymentMethod',
  ];

  protected $casts = [
    'TotalAmount' => 'decimal:2',
    'PaymentStatus' => 'string', // Enum: Pending, Completed, Failed
    'PaymentMethod' => 'string', // Enum: CreditCard, PayPal, BankTransfer
  ];

  public function bookingDetail() {
    return $this->belongsTo(Booking::class, 'BookingDetailID');
  }

  public function cashPayment() {
    return $this->hasOne(PaymentType_Cash::class, 'PaymentInfoID');
  }

  public function cardPayment() {
    return $this->hasOne(PaymentType_Card::class, 'PaymentInfoID');
  }

  public function ePayment() {
    return $this->hasOne(PaymentType_EPayment::class, 'PaymentInfoID');
  }

  public function paypalPayment() {
    return $this->hasOne(PaymentType_Paypal::class, 'PaymentInfoID');
  }

  public function bankTransferPayment() {
    return $this->hasOne(PaymentType_BankTransfer::class, 'PaymentInfoID');
  }
}


// Models\PaymentType_BankTransfer.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class PaymentType_BankTransfer extends Model {
  protected $table = 'PaymentType_BankTransfer';
  protected $primaryKey = 'ID';
  protected $fillable = [
    'PaymentInfoID',
    'AccountName',
    'AccountNumber',
    'RoutingNumber',
  ];

  public function paymentInfo() {
    $this->belongsTo(PaymentInfos::class, 'PaymentInfoID', 'ID');
  }
}


// Models\PaymentType_Card.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class PaymentType_Card extends Model {
  protected $table = 'PaymentType_Card';
  protected $fillable = ['PaymentInfoID', 'Name', 'CardNumber', 'Expiry', 'CVC'];

  protected $casts = [
    'CardNumber' => 'encrypted',
    'CVC' => 'encrypted',
  ];

  public function paymentInfo() {
    return $this->belongsTo(PaymentInfos::class, 'PaymentInfoID', 'ID');
  }
}


// Models\PaymentType_Cash.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class PaymentType_Cash extends Model {
  protected $table = 'PaymentType_Cash';

  protected $primaryKey = 'ID';
  protected $fillable = ['PaymentInfoID', 'CashAmount'];

  protected $casts = [
    'Amount' => 'decimal:2',
  ];

  public function paymentInfo() {
    return $this->belongsTo(PaymentInfos::class, 'PaymentInfoID', 'ID');
  }
}


// Models\PaymentType_EPayment.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class PaymentType_EPayment extends Model {
  protected $table = 'PaymentType_EPayment';
  protected $fillable = ['PaymentInfoID', 'Name', 'Number', 'Amount', 'ReferenceNum'];

  protected $casts = [
    'Amount' => 'decimal:2',
  ];

  public function paymentInfo() {
    return $this->belongsTo(PaymentInfos::class, 'PaymentInfoID', 'ID');
  }
}


// Models\PaymentType_Paypal.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class PaymentType_Paypal extends Model {
  protected $table = 'PaymentType_Paypal';
  protected $primaryKey = 'ID';
  protected $fillable = [
    'PaymentInfoID',
    'Name',
    'Amount',
    'ReferenceNumber',
  ];

  protected $casts = [
    'Amount' => 'decimal:2'
  ];

  public function paymentInfo() {
    $this->belongsTo(PaymentInfos::class, 'PaymentInfoID', 'ID');
  }
}


// Models\Room.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Room extends Model {
  protected $table = 'Rooms';
  protected $primaryKey = 'ID';
  protected $fillable = [
    'RoomName',
    'RoomTypeID',
    'RoomSizeID',
    'Floor'
  ];

  
  public function roomType() {
    return $this->belongsTo(RoomType::class, 'RoomTypeID', 'ID');
  }

  public function roomSize() {
    return $this->belongsTo(RoomSize::class, 'RoomSizeID', 'ID');
  }

  public function assignedRooms() {
    return $this->hasMany(AssignedRoom::class, 'RoomID', 'ID');
  }
}


// Models\RoomSize.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class RoomSize extends Model {
  protected $table = 'RoomSizes';
  protected $primaryKey = 'ID';
  protected $fillable = ['RoomSizeName', 'RoomSizeDescription', 'RoomCapacity', 'PricePerPerson', 'RoomSizePrice'];

  protected $casts = [
    'RoomCapacity' => 'integer',
    'PricePerPerson' => 'decimal:2',
    'RoomSizePrice' => 'decimal:2',
  ];

  public function rooms() {
    return $this->hasMany(Room::class, 'RoomSizeID', 'ID');
  }

  public function bookings() {
    return $this->hasMany(Booking::class, 'RoomSizeID', 'ID');
  }
}


// Models\RoomType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class RoomType extends Model {
  protected $table = 'RoomTypes';
  protected $primaryKey = 'ID';
  protected $fillable = [
    'RoomTypeName',
    'RoomDescription',
    'RoomPrice',
    'SucceedingNights',
    'ImagePathname',
    'ImageName',
    'MimeType',
  ];

  protected $casts = [
    'RoomPrice' => 'decimal:2',
    'SucceedingNights' => 'decimal:2',
  ];

  public function bookings() {
    return $this->hasMany(Booking::class, 'RoomTypeID', 'ID');
  }

  public function rooms() {
    return $this->hasMany(Room::class, 'RoomTypeID', 'ID');
  }
}


// Models\Service.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Service extends Model {
  protected $table = 'Services';

  protected $primaryKey = 'ID';

  protected $fillable = [
    'ServiceName',
    'ServiceDescription',
    'ServicePrice',
    'ServiceStatus',
    'ImagePathname',
    'ImageName',
    'MimeType',
  ];

  protected $casts = [
    'ServicePrice' => 'decimal:2',
    'ServiceStatus' => 'string', // Enum: Available, Unavailable
  ];

  public function servicesAdded(): HasMany {
    return $this->hasMany(ServiceAdded::class, 'ID', 'ID');
  }
}


// Models\ServiceAdded.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class ServiceAdded extends Model {
  protected $table = 'ServicesAdded';
  protected $fillable = ['BookingDetailID', 'ServiceID'];

  public function bookingDetail() {
    return $this->belongsTo(Booking::class, 'BookingDetailID');
  }

  public function service() {
    return $this->belongsTo(Service::class, 'ServiceID', 'ID');
  }
}


// Models\User.php
<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

class User extends Authenticatable {
  /** @use HasFactory<\Database\Factories\UserFactory> */
  use HasFactory, Notifiable;

  /**
   * The attributes that are mass assignable.
   *
   * @var list<string>
   */

  // protected $primaryKey = 'ID';
  protected $fillable = [
    'Name',
    'Username',
    'email',
    'password',
    'Role',
  ];

  /**
   * The attributes that should be hidden for serialization.
   *
   * @var list<string>
   */
  protected $hidden = [
    'password',
    'remember_token',
  ];

  /**
   * Get the attributes that should be cast.
   *
   * @return array<string, string>
   */
  protected function casts(): array {
    return [
      'email_verified_at' => 'datetime',
      'password' => 'hashed',
    ];
  }

  public function bookingDetails(): HasMany {
    return $this->hasMany(Booking::class, 'ID', 'id');
  }
  public function loyalty(): HasOne {
    return $this->hasOne(UserLoyalty::class, 'UserID', 'ID');
  }
}


// Models\UserLoyalty.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class UserLoyalty extends Model {
  protected $table = 'UserLoyalty';
  protected $primaryKey = 'ID';
  protected $fillable = ['UserID', 'LoyaltyPoints', 'LoyaltyTierID'];

  protected $casts = [
    'LoyaltyPoints' => 'decimal:2',
  ];

  public function user() {
    return $this->belongsTo(User::class, 'UserID', 'ID');
  }

  public function loyaltyTier() {
    return $this->belongsTo(LoyaltyTier::class, 'LoyaltyTierID', 'ID');
  }
}


// Providers\AppServiceProvider.php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Pagination\Paginator;

class AppServiceProvider extends ServiceProvider {
  /**
   * Register any application services.
   */
  public function register(): void {
    //
  }

  /**
   * Bootstrap any application services.
   */
  public function boot(): void {
    Paginator::defaultView('vendor.pagination.custom');
  }
}


